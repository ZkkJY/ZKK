Mysql常用的三种引擎：
ISAM:
ISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源。
ISAM的两个主要不足之处在于，它不支持事务处理，也不能够容错
MyISAM:
除了提供ISAM里所没有的索引和字段管理的大量功能，
MyISAM还使用一种表格锁定的机制，来优化多个并发的读写操作,
MyISAM格式的一个重要缺陷就是不能在表损坏后恢复数据
InnoDB:
InnoDB包括了对事务处理和外来键的支持,持事务处理，支持外键，支持崩溃修复能力和并发控制。
如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），
那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，
因为支持事务的提交（commit）和回滚（rollback）。 

多线程、线程池:
线程池是线程的集合。在没有任务时线程处于空闲状态，当请求到来,
线程池给这个请求分配一个空闲的线程，任务完成后回到线程池中等待下次任务(而不是销毁)。
这样就实现了线程的重用。
1、降低资源消耗：可以重复利用已创建的线程降低线程创建和销毁造成的消耗。
2、提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。
3、提高线程的可管理性：线程是稀缺资源，如果无限制地创建，
不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控
线程池的工作原理

多线程是指一个进程中不只有一个线程。
①、为了更好的利用cpu的资源，如果只有一个线程，
则第二个任务必须等到第一个任务结束后才能进行，
如果使用多线程则在主线程执行任务的同时可以执行其他任务，而不需要等待；
②、进程之间不能共享数据，线程可以；
③、系统创建进程需要为该进程重新分配系统资源，创建线程代价比较小；
④、Java语言内置了多线程功能支持，简化了java多线程编程。

 LintCode - 反转二叉树
  1         1
 / \       / \
2   3  => 3   2
   /       \
  4         4
采用递归的思路，判断特殊条件后，先交换根节点的左右孩子，然后再对其左右子树进行递归调用。

notify工作原理
在notify方法调用时，只会去唤醒等待池中的一个线程
如果没有被唤醒的线程，将一直处于等待池中，
由于我们的线程没有设置成daemon线程，
所以处于等待池中的线程如果一直没有被唤醒，那么我们的程序将不会停止。

 tomcat容器启动，jvm加载情况描述
当tomcat启动时，会创建几种类加载器：
1 使用bootstrap引导类加载器加载
2 使用system系统类加载器加载
3 使用应用类加载器在WEB-INF/classes中加载
4 使用应用类加载器在WEB-INF/lib中加载
5 使用common类加载器在CATALINA_HOME/lib中加

volatile的用途
volatile让变量每次在使用的时候，都从主存中取。而不是从各个线程的“工作内存”。
volatile变量对于每次使用，线程都能得到当前volatile变量的最新值。
但是volatile变量并不保证并发的正确性。

简单说一下IOC和AOP
为了解决对象之间的耦合度过高的问题，IOC也称依赖注入或控制反转，
就是用来实现对象之间的“解耦”，所谓依赖，从程序的角度看，
就是比如A要调用B的方法，那么A就依赖于B，如果不倒置，意思就是A主动获取B的实例，
ioc的依赖倒置就可以让B倒置到A中

AOP
即面向切面编程，面向切面编程的目标就是分离关注点，
AOP的好处就是你只需要干你的正事，其它事情别人帮你干，
AOP最大的用途就在于提供了事务管理的能力，
Spring在你访问数据库之前，自动帮你开启事务，
当你访问数据库结束之后，自动帮你提交/回滚事务。

动态代理
代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，
静态代理：由程序员创建或特定工具自动生成源代码，
也就是在编译时就已经将接口，被代理类，代理类等确定下来。
在程序运行之前，代理类的.class文件就已经生成
动态代理：代理类在程序运行时创建的代理方式被成为动态代理，
动态代理其实就是AOP的一个简单实现。

静态方法和普通方法同时加上synchronized有什么区别
synchronized是Java中的关键字，是一种同步锁,
它修饰一个普通方法，被修饰的方法称为同步方法，
其作用的范围是整个方法，作用的对象是调用这个方法的对象；
它修改一个静态的方法，其作用的范围是整个静态方法，
作用的对象是这个类的所有对象； 

事务隔离的级别
读未提交，读提交，可重复度，串行化

group by 和distinct性能比较。
 group by 都比 distinct 快，数据量小的时候distinct快，

关系型数据库和非关系型
Oracle，MySQL，DB2， SQLite，SQL Server
Redis，Memcached

hashtable和hashmap的区别
1.HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行。
2.HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。
3.Hashtable是线程安全，而HashMap则非线程安全
4.HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。
5.HashMap扩容时是当前容量翻倍，Hashtable扩容时是容量翻倍+1。
6.HashMap和Hashtable的底层实现都是数组+链表结构实现。

string、stringbuilder、stringbuffer区别
运行速度：StringBuilder > StringBuffer > String
String最慢的原因：String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，
即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。
在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的
String：适用于少量的字符串操作的情况
StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况
StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况

 Java 的引用类型有哪几种
强引用：当我们使用new创建对象时，被创建的对象就是强引用
软引用：如果一个对象只具备软引用，如果内存空间足够，那么JVM就不会GC它，反之就会GC
弱引用：如果一个对象只具有弱引用，只要JVM的GC线程检测到了，就会立即回收。
虚引用：如果一个对象只具有虚引用，那么它就和没有任何引用一样，随时会被JVM当作垃圾进行GC。 

HashMap的工作原理是什么？
HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，
使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，
我们先对键调用hashCode()方法，
计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。
这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node 。

Hash冲突怎么办？哪些解决散列冲突的方法？
当冲突发生时，使用某种探查技术在散列表中形成一个探查(测)序列。
沿此序列逐个单元地查找，直到找到给定的地址。
开放定址法。

讲讲NiO
传统的IO流是阻塞式的,对于NIO，它是非阻塞式，核心类：
1.Buffer为所有的原始类型提供 (Buffer)缓存支持。
2.Charset字符集编码解码解决方案
3.Channel一个新的原始 I/O抽象，用于读写Buffer类型，
通道可以认为是一种连接，可以是到特定设备，程序或者是网络的连接。

String编码UTF-8和GBK的区别
UTF-8是国际通用的编码，通用性比较好，GBK是国家编码，
支持中文，但是相比UTF-8的通用性差，不过UTF-8占用的数据库比较大，所以相对反应速度要慢。

什么时候使用字节流，什么时候    使用字符流
所有的输入都是转换成字节流之后，然后在内存中变成字符流。
所以一般建议使用字符流。但是遇到中文汉字，出现乱码的情况下，可以使用字节流。

 session和cookie的区别和联系
1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，
考虑到安全应当使用session。
3、session会在一定时间内保存在服务器上。当访问增多，
会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。
4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
5、可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。

webservice是什么？
    1.基于WEB的服务，服务端整出一些资源让客户端应用访问（提供数据）
    2.webservice是一个跨语言跨平台的规范（抽象）
    3.是多个跨语言跨平台的应用间通信整合的方案（实际）

get和post方法的区别是什么？
    （1）get方法提交的参数会通过url传递，而post提交的内容是放在请求体中的。
    （2）get传送的数据量比较小，post传送的数据量比较大，通常认为不受限制。
    （3）get方法不安全因为将传送数据暴露在url上，而post则不存在这个问题。
    （4）超链接和表单的默认提交方式都是get。

jsp和servlet的区别和联系：
1.jsp经编译后就变成了Servlet,JSP的本质就是Servlet
2.jsp更擅长表现于页面显示,servlet更擅长于逻辑控制.
3.Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，
HttpServletResponse对象以及HttpServlet对象得到.
4.Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容

GC 算法，永久代对象如何 GC，GC 有环怎么处理?
永久代GC的原因：
1.永久代空间已经满了 2.
调用了System.gc()
, 
这种GC是full GC 堆空间也会一并被GC一次


.
GC有环怎么处理:

根搜索算法
,根搜索算法是
垃圾回收器从被称为GC?Roots的点开始遍历遍历对象，
凡是可以达到的点都会标记为存活，堆中不可到达的对象都会标记成垃圾，然后被清理掉。

java GC是在什么时候，对什么东西，做了什么事情？
在什么时候：能说出新生代、老年代结构，能提出minor gc/full gc
对什么东西：从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。
做什么：删除不使用的对象，回收内存空间；
运行默认的finalize,当然程序员想立刻调用就用dipose调用以释放资源如文件句柄，
JVM用from survivor、to survivor对它进行标记清理，对象序列化后也可以使它复活。

如果某个对象想在 GC 中生存 1 次怎么办？
想在对象生命周期中至少被GC一次后存活，最简单的方法是重写Object的finalize()，
在对象的finalize方法中重新建立引用，但是由于此方法只会被调用一次，所以能在GC中生存一次。

为什么要使用SpringMVC？
SpringMVC对servlet进行封装
    比如请求参数的映射。文件的上传，支持各种视图解析器
    而servlet只有doGet和doPost，一个servlet类只能处理一个url-pattern
    SpringMVC类里面可以通过RequestMapping处理很多请求，并且支持Rest风格的请求
    SpringMVC参数的映射可以直接封装成实体类
言归正传其实就是为了使用者只关心核心业务的开发，
框架帮你屏蔽原有技术跟业务开发无关的各类技术问题

什么是mybatis 为什么要使用mybatis？
MyBatis是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。
因为MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。
MyBatis可以使用简单的XML或注解用于配置和原始映射，
将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。

Spring框架的好处，为什么要用Spring?
1.方便解耦，便于开发（Spring就是一个大工厂，
可以将所有对象的创建和依赖关系维护都交给spring管理）


2.spring支持aop编程（spring提供面向切面编程，
可以很方便的实现对程序进行权限拦截和运行监控等功能）


3.声明式事务的支持（通过配置就完成对事务的支持，不需要手动编程）


4.方便程序的测试，spring 对junit4支持，可以通过注解方便的测试spring 程序


5.方便集成各种优秀的框架（）


6.降低javaEE API的使用难度（Spring 对javaEE开发中非常难用的一些API 
例如JDBC,javaMail,远程调用等，都提供了封装，是这些API应用难度大大降低）


数组（array）和列表（arrayList）有什么区别？什么时候应该使用Array而不是ArrayList？

1）Array数组可以包含基本类型和对象类型， ArrayList却只能包含对象类型。


2） Array数组在存放的时候一定是同种类型的元素。ArrayList就不一定了，
因为ArrayList可以存储Object。


3）Array的空间大小是固定的，空间不够时也不能再次申请，
所以需要事前确定合适的空间大小。

ArrayList的空间是动态增长的，如果空间不够，
它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，
接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够。
（比较麻烦的地方）。


4）方法上的比较：ArrayList作为Array的增强版，当然是在方法上比Array更多样化，
比如添加全部addAll()、删除全部removeAll()、返回迭代器iterator()等。
